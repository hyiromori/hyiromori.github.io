---
title: "OpenID Connect についてと OAuth2.0 との違いを調べてみた"
emoji: "🔐"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["OIDC", "OpenIDConnect"]
published: false
---

# はじめに

最近、個人的に認証認可周りを学習していて、今回は OpenID Connect について学習したのでその内容をまとめた記事です。

世の中には既に OpenID Connect に関する優れた書籍やブログ記事が沢山ありますが、自分が学習する過程で色々なものを読むことでより理解が深まったと思うので、自分も学習したものをアウトプットすることで同じように学習している人の理解の助けになればと思い書きました。

この記事は [OAuth2.0の流れをまとめてみる](https://zenn.dev/hyiromori/articles/2020-12-28-oauth2) の続きという位置づけになっています。
OAuth2.0が分からないという方はこちらを先に読むことをおすすめします。

まだ私も学習中なので、もし間違ったところなどあればコメント頂けるとありがたいです。

# OpenID Connect とはなにか？

OAuth2.0をベースにして（認可だけでなく）認証も行えるようにした拡張仕様です。

なぜOAuth2.0が認証に使えないかというと、以下のように認証に使ってしまうとリスクが非常に高いからです。

https://www.sakimura.org/2012/02/1487/

ざっくりかいつまんで言うと、以下のようになります。

- OAuth2.0 を認証に使うということは、有効なアクセストークンをもって認証できたとみなす
- しかしアクセストークンには「いつ」「どこで」「なんのために」作られてものかが分からない
- 例えば悪意があるサイトなどが、ユーザーから取得したアクセストークンを別サイトのログインに使ってなりすますなどの危険性がある

こういった事情から、OAuth2.0で発行されたアクセストークンを認証に使ってはいけません。

:::message
ちなみに認証に使えないことはOAuth2.0の問題ではありません。
OAuth2.0はあくまで「認可」を対象にした仕様なので、対象外である「認証」に使って問題が発生することは当然です。
:::

# OAuth2.0 との一番大きな差分

一番大きな違いは「IDトークン」が発行されることです。
IDトークンはアクセストークンにはない「いつ」「どこで」「なんのために」発行されたトークンなのかの情報を含んでおり、かつ署名されているため改ざんができない（改ざんを検知できる）ようになっています。

:::message
用語が違ったり、UserInfoエンドポイントを実装するなどの違いもありますが、この記事では対象外とさせていただきます。
:::

# IDトークンとはなにか？

IDトークンは JWT (JSON Web Token) という形式の文字列になっています。

Googleから取得したIDトークンを例に見てみましょう。

`jwt` コマンドはこちらを使用しています。

https://github.com/mike-engel/jwt-cli

```bash
$ jwt decode 'eyJh...8UOg'

Token header
------------
{
  "typ": "JWT",
  "alg": "RS256",
  "kid": "783ec031c59e11f257d0ec15714ef607ce6a2a6f"
}

Token claims
------------
{
  "at_hash": "u1...XA",
  "aud": "95...8u.apps.googleusercontent.com",
  "azp": "95...8u.apps.googleusercontent.com",
  "email": "hyiromori@gmail.com",
  "email_verified": true,
  "exp": 1611135338,
  "iat": 1611131738,
  "iss": "https://accounts.google.com",
  "sub": "10...08"
}
```

(文字数が多い値や秘匿したい値は `...` としています)

`Token header` の部分は、JWT の形式などを定義しています。

`Token claims` の部分が実際のデータというところです。
特に注目すべきなのは `aud (AUDience)`, `exp (EXPiration)` です。

`aud (AUDience)` はトークンの受け手を指しています。
これは設定時にGoogleから発行された値で、これを検証することでGoogleが自サイト向けの認証時に発行されたことが確認できます。

`exp (EXPiration)` はトークンの有効期限です。
これを検証することで、有効な（古くない）トークンであることを確認できます。

なお `iat (Isused AT)` はIDトークンが発行された日時（UNIX時間）なので、これと有効期限を比較するとGoogleのIDトークンの生存時間が分かります。
`Node.js` を使って簡単に見てみました。

```javascript
var d = new Date()

d.setTime(1611131738 * 1000) // JSはミリ秒単位なので1,000倍する
console.log("Issued at", d)
// => Issued at 2021-01-20T08:35:38.000Z

d.setTime(1611135338 * 1000) // JSはミリ秒単位なので1,000倍する
console.log("Expire at", d)
// =>Expire at 2021-01-20T09:35:38.000Z
```

１時間ほどで切れるようになっていますね。
つまりきちんと検証することで「自サイト向けに」「１時間以内に認証して発行された（Googleの場合）」IDトークン以外は受け付けないようにできます。
これで OAuth2.0 のアクセストークンをそのまま使った場合の起きるなりすましのような脆弱性が解消されました。



# OAuth2.0でのフローの差分

この記事内ではOAuth2.0で定義されているフローの1つ、認可コードによる付与（Authorization Code Grant）をベースに差分を説明します。

[OAuth2.0の流れをまとめてみる](https://zenn.dev/hyiromori/articles/2020-12-28-oauth2#oauth2.0%E3%81%AE%E6%B5%81%E3%82%8C) との差分をメインに記述するので、OAuth2.0がまだあまり理解できていない方はこちらも合わせてご覧ください。

## 1.認可サーバーへのリダイレクト

![Redirect to authorization Server](https://i.gyazo.com/06a4969d7bc46138426ff1ad2c598c48.jpg)

Googleと連携したい時に、クライアントから必要なパラメーターを付与して、Googleの認可サーバーへのリダイレクトさせます。

その際に `scope` に `openid` を指定する、というのが OAuth2.0 と OpenID Connect の一番の違いです。

### HTTPの例

クライアント（Webアプリ）内のリンクなどをクリックすると、リダイレクト専用のエンドポイント（例: `/request_authorize`）にアクセスします。

```http
GET /request_authorize HTTP/1.1
Host: https://client.example.com
```

このエンドポイントからは必要な情報をクエリパラメーターにセットされたURLが返却されて、Googleの認可サーバーへリダイレクトします。

```http
HTTP/1.1 302 Found
Location: https://accounts.google.com/o/oauth2/v2/auth?client_id=(CLIENT_ID)&redirect_uri=https%3A%2F%2client.example.com%2Fcallback&scope=openid%20email&response_type=code
```

:::message
`scope=openid` のように `openid` というスコープが追加されます。
:::

## 2.認可サーバーでの確認

![Authenticate on authorization server](https://i.gyazo.com/2522afa12f8a1ac3d3b34979b403f347.jpg)

リソースオーナーに対して、要求されている認可を許可してよいかどうかを確認されます。
リソースオーナーは必要に応じてパスワードなどで認証を行い、要求されているスコープを確認して、問題なければ許可します。

Googleでの例 ⬇
![Google authentication example](https://i.gyazo.com/fc422b9b53a5bdb45670d6cf456d2e7a.png)

## 3.認可コードの発行

![Issue authorization code](https://i.gyazo.com/1ffbb8f6682b15c9f1b92603c5879a2c.jpg)

許可されると、アクセストークンを発行するための認可コードを発行して、クライアントへリダイレクトします。
先に説明したとおり認可コードが外部にもれないよう、リダイレクトは事前に設定されたURLのみ可能です。（大事なことなので2回書きました）

### HTTPの例

以下のように認可コードをクエリパラメーターに設定された状態でリダイレクトします。

```http
HTTP/1.1 302 Found
Location: https://client.example.com/callback?code=(認可コード)
```

クライアント（Webアプリ）で定義されたエンドポイント（例: `/callback`）に認可コードが渡されます。

```http
GET /callback?code=(認可コード) HTTP/1.1
Host: https://client.example.com
```

## 4.アクセストークンとIDトークンの発行

![Issue access token by authorization server](https://i.gyazo.com/3daaf41950470eb5104f4819509c775d.jpg)

リダイレクト時に付与された認可コードを認可サーバーに渡して、アクセストークンと **IDトークン** を取得します。

# 参考資料

- [一番分かりやすい OpenID Connect の説明 - Qiita](https://qiita.com/TakahikoKawasaki/items/498ca08bbfcc341691fe)
- [OpenID Connect 全フロー解説 - Qiita](https://qiita.com/TakahikoKawasaki/items/4ee9b55db9f7ef352b47)

