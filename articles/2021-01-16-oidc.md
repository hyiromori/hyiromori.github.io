---
title: "OpenID Connect についてと OAuth2.0 との違いを調べてみた"
emoji: "🔐"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["OIDC", "OpenIDConnect"]
published: false
---

# はじめに

最近、個人的に認証認可周りを学習していて、今回は OpenID Connect について学習したのでその内容をまとめた記事です。

世の中には既に OpenID Connect に関する優れた書籍やブログ記事が沢山ありますが、自分が学習する過程で色々なものを読むことでより理解が深まったと思うので、自分も学習したものをアウトプットすることで同じように学習している人の理解の助けになればと思い書きました。

この記事は [OAuth2.0の流れをまとめてみる](https://zenn.dev/hyiromori/articles/2020-12-28-oauth2) の続きという位置づけになっています。
OAuth2.0が分からないという方はこちらを先に読むことをおすすめします。

まだ私も学習中なので、もし間違ったところなどあればコメント頂けるとありがたいです。

# OpenID Connect とはなにか？

OAuth2.0をベースにして（認可だけでなく）認証も行えるようにした拡張仕様です。

なぜOAuth2.0が認証に使えないかというと、以下のように認証に使ってしまうとリスクが非常に高いからです。

https://www.sakimura.org/2012/02/1487/

ざっくりかいつまんで言うと、以下のようになります。

- OAuth2.0 を認証に使うということは、有効なアクセストークンをもって認証できたとみなす
- しかしアクセストークンには「いつ」「どこで」「なんのために」作られてものかが分からない
- 例えば悪意があるサイトなどが、ユーザーから取得したアクセストークンを別サイトのログインに使ってなりすますなどの危険性がある

こういった事情から、OAuth2.0で発行されたアクセストークンを認証に使ってはいけません。

:::message
ちなみに認証に使えないことはOAuth2.0の問題ではありません。
OAuth2.0はあくまで「認可」を対象にした仕様なので、対象外である「認証」に使って問題が発生することは当然です。
:::

# OAuth2.0 との一番大きな差分

用語が違ったりするなど細かい点はありますが、一番大きな違いは「IDトークン」が発行されることです。
IDトークンはアクセストークンにはない「いつ」「どこで」「なんのために」発行されたトークンなのかの情報を含んでおり、かつ署名されているため改ざんができない（改ざんを検知できる）ようになっています。

# IDトークンとはなにか？

IDトークンは JWT (JSON Web Token) という形式の文字列になっています。

Googleから取得したIDトークンを例に見てみましょう。

`jwt` コマンドはこちらを使用しています。

https://github.com/mike-engel/jwt-cli

```bash
$ jwt decode 'eyJh...8UOg'

Token header
------------
{
  "typ": "JWT",
  "alg": "RS256",
  "kid": "783ec031c59e11f257d0ec15714ef607ce6a2a6f"
}

Token claims
------------
{
  "at_hash": "u1...XA",
  "aud": "95...8u.apps.googleusercontent.com",
  "azp": "95...8u.apps.googleusercontent.com",
  "email": "hyiromori@gmail.com",
  "email_verified": true,
  "exp": 1611135338,
  "iat": 1611131738,
  "iss": "https://accounts.google.com",
  "sub": "10...08"
}
```

(文字数が多い値や秘匿したい値は `...` としています)

`Token header` の部分は、JWT の形式などを定義しています。

`Token claims` の部分が実際のデータというところです。
特に注目すべきなのは `aud (AUDience)`, `exp (EXPiration)` です。

`aud (AUDience)` はトークンの受け手を指しています。
これは設定時にGoogleから発行された値で、これを検証することでGoogleが自サイト向けの認証時に発行されたことが確認できます。

`exp (EXPiration)` はトークンの有効期限です。
これを検証することで、有効な（古くない）トークンであることを確認できます。

なお `iat (Isused AT)` はIDトークンが発行された日時（UNIX時間）なので、これと有効期限を比較するとGoogleのIDトークンの生存時間が分かります。
`Node.js` を使って簡単に見てみました。

```javascript
var d = new Date()

d.setTime(1611131738 * 1000) // JSはミリ秒単位なので1,000倍する
console.log("Issued at", d)
// => Issued at 2021-01-20T08:35:38.000Z

d.setTime(1611135338 * 1000) // JSはミリ秒単位なので1,000倍する
console.log("Expire at", d)
// =>Expire at 2021-01-20T09:35:38.000Z
```

１時間ほどで切れるようになっていますね。
つまりきちんと検証することで「自サイト向けに」「１時間以内に認証して発行された（Googleの場合）」IDトークン以外は受け付けないようにできます。
これで OAuth2.0 のアクセストークンをそのまま使った場合の起きるなりすましのような脆弱性が解消されました。



# OAuth2.0でのフローの差分

この記事内ではOAuth2.0で定義されているフローの1つ、認可コードによる付与（Authorization Code Grant）をベースに差分を説明します。

# 参考資料

- [一番分かりやすい OpenID Connect の説明 - Qiita](https://qiita.com/TakahikoKawasaki/items/498ca08bbfcc341691fe)
- [OpenID Connect 全フロー解説 - Qiita](https://qiita.com/TakahikoKawasaki/items/4ee9b55db9f7ef352b47)

